\chapter{Introduction}
\label{chap:intro}

This chapter aims to give an intuitive understanding of the branch-and-bound and
the backtracking methods, provide examples of problems commonly solved with these methods,
and present the goal of the presented work.

\section{Backtracking and branch-and-bound methods}

Backtracking and branch-and-bound (B\&B) methods are methods used in
algorithms for solving discrete optimization problems. Both methods are also used for solving
% TODO: IS THERE A TERM FOR SUCH PROBLEMS??
problems where it is sufficient to find a single solution under given constraints
(e.g., Sudoku). Such problems can be seen as special cases of discrete optimization with
binary objective functions.

Both methods solve a problem by recursively splitting it into subproblems. Generated
subproblems are evaluated: if it can be determined that the best potentially achievable
solution to a subproblem is not better than the current best solution candidate
(\emph{incumbent}), the subproblem is discarded
and its subproblems are not considered.

If a generated subproblem is a \emph{leaf} subproblem, meaning that it can be solved directly
without being split, it is solved. If the objective function value at the solution is better
than that in the incumbent, the solution becomes the new incumbent.

% TODO: IS THERE A TERM FOR SUCH PROBLEMS?? (I called them `single-solution` here)
In the special case of a single-solution problem (such as Sudoku), no candidate solution
is better than any other candidate solution, thus, as soon as any solution is found,
all other subproblems can be rejected, and the algorithm can terminate.

\sloppy
The primary difference between the backtracking and branch-and-bound methods
is in the order in which subproblems are generated and evaluated. A backtracking-based
algorithm, given a problem, will first generate and fully evaluate the first subproblem
of the given problem, and process all of its subproblems; only after that will it proceed with
the second (and further) subproblem(s) of the given problem. Overall, the subproblem
consideration order is similar to depth-first search in a graph.

On the other hand, a branch-and-bound-based algorithm, given a problem,
will generate all of its subproblems and add them to the set of subproblems to be considered
(\emph{live nodes}). On every iteration, the algorithm will select a subproblem from the set,
following a \emph{selection strategy}, e.g., first-come-first-served. Subproblem consideration
order of branch-and-bound can, thus, be similar to breadth-first search in a graph, or
something else, depending on the selection strategy.

\section{Problem examples}

\subsection{Boolean satisfiability problem (CNF SAT)}

The Boolean satisfiability problem, sometimes abbreviated as CNF SAT, is as follows:
given a Boolean formula in the conjunctive normal form, find the set of variable assignments
for which the formula is satisfied (i.e., evaluates to true), if there is any.

For example, for the formula $a \land \neg b$, the assignment $a=\text{T}, b=\text{F}$
satisfies the formula, while the formula $a \land \neg a$ is \emph{unsatisfiable}.

The boolean satisfiability problem can be solved with the following backtracking-based
algorithm: a recursive function accepts a formula, the current variable assignment
(initially, an empty set), and a queue of variables left to assign. The function pops a
variable from the queue and gets a variable to assign a value to. For every possible variable
value (namely, true and false), the function tries to assign it to the variable
and solve the problem recursively. If the solution is not found, another assignment is
attempted. The first solution found is returned.

\sloppy
The function is implemented in pseudo-code in algorithm \ref{alg:cnf_sat},
where $assign(assignment, var, val)$ returns a modified copy of $assignment$ with the value
of variable $var$ assigned to $val$; $unsatisfied(formula, assignment)$ evaluates the formula
and returns true if the formula is known to be unsatisfied, given the variable assignment.

\begin{algorithm}
\caption{CNF SAT solving algorithm based on the backtracking method, pseudo-code}
\label{alg:cnf_sat}
\begin{algorithmic}
\Procedure{solve}{formula, assignment, varsLeft}
    \If {$varsLeft = \varnothing$}
        \State \Return{$assignment$}
    \EndIf

    \State

    \State $nextVar \gets varsLeft.pop()$
    \ForAll{$val \in \{\text{T}, \text{F}\}$}
        \State $assignment \gets assign(assignment, nextVar, val)$
        \If{$\neg unsatisfied(formula, assignment)$}
            \State $solution \gets solve(formula, assignment, varsLeft)$
            \If{$solution \neq \varnothing$}
                \State \Return{$solution$}
            \EndIf
        \EndIf
    \EndFor

    \State

    \State \Return{$\varnothing$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Knapsack problem}

The Knapsack problem is as follows: given a lifting capacity value and a set of items,
each having a weight and a price, find a subset of items that has the maximum possible
cumulative price given that the cumulative weight shall not exceed the lifting capacity value.

The Knapsack problem can be solved with the following branch-and-bound-based algorithm:
a function maintains the current best solution (initially, an empty knapsack) and a queue where
each entry represents a pre-packed Knapsack and is a triple:
price accumulated, lifting capacity left, set of unprocessed items. On every iteration,
an entry is popped from the queue and evaluated: if it has a potential of surpassing the
current best solution (see below for details), an item is extracted from the set of unprocessed
items, and two options are considered: including the item (if possible) and not including it.
The corresponding entries are added to the queue.

\sloppy
The function is implemented in pseudo-code in algorithm \ref{alg:knapsack},
where $maxAchievablePrice$ is a function of entry that gives an upper boundary of the maximum
price achievable from the given state. One way to implement it (the one that was implemented
as part of the presented work) is to try to greedily include all remaining items starting with
the most valuable ones, until the lifting capacity value is \emph{exceeded}
(i.e., the constraint is no longer satisfied). It can be shown that the cumulative price
achieved in this case is an upper boundary of the best value that can be achieved while
satisfying the constraint.

\begin{algorithm}
\caption{Knapsack problem solving algorithm based on the branch-and-bound method, pseudo-code}
\label{alg:knapsack}
\begin{algorithmic}
\Procedure{solve}{items, maxWeight}
    \State $queue \gets \{(0, maxWeight, items)\}$
    \State $incumbentPrice \gets 0$
    \State $incumbent \gets \varnothing$
    \While{$queue \neq \varnothing$}
        \State $entry \gets queue.pop()$
        \If{$maxAchievablePrice(entry) > incumbentPrice$}
            \State $(price, capacity, items) \gets entry$
            \State $(iPrice, iWeight) \gets items.pop()$
            \If{$capacity \ge iWeight$}
                \State $queue.push((price + iPrice, capacity - iWeight, items))$
            \EndIf
            \State $queue.push((price, capacity, items))$
        \EndIf
    \EndWhile
    \State \Return{$incumbent$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Goal of study}

The goal of the presented work is to design and develop a template library for implementing
backtracking- and B\&B-based algorithms without having to reimplement their common parts.

% =========== TEMPLATE STUFF BELOW ===========

%\chaptermark{Optional running chapter heading}
%\section{Spacing \& Type}
%\label{sec:section}

%This is a section. This is a citation without brackets. and this is one with brackets \cite{A}. Multiple \cite{A,B,C} Here's a reference to a subsection: \ref{sec:subsection}. Citation of an online article \cite{D}. Citation of an online proceeding \cite{F}. The body of the text and abstract must be double-spaced except for footnotes or long quotations. Fonts such as Times Roman, Bookman, New Century Schoolbook, Garamond, Palatine, and Courier are acceptable and commonly found on most computers. The same type must be used throughout the body of the text. The font size must be 10 point or larger and footnotes\footnote{This is a footnote.} must be two sizes smaller than the text\footnote{This is another footnote.} but no smaller than eight points. Chapter, section, or other headings should be of a consistent font and size throughout the ETD, as should labels for illustrations, charts, and figures.

%\subsection{Creating a Subsection}
%\label{sec:subsection}

%\subsubsection{Creating a Subsubsection}
%\subsubsection{Creating a Subsubsection}
%\subsubsection{Creating a Subsubsection}

%\paragraph{This is a heading level below subsubsection}

%And this is a quote:
%
%\begin{quote}
%\blindtext
%\end{quote}

% \begin{figure}[hbt]
% \centering
% \includegraphics[]{figs/IU.png}
% \caption{One kernel at $x_s$ (\emph{dotted kernel}) or two kernels at
% $x_i$ and $x_j$ (\textit{left and right}) lead to the same summed estimate
% at $x_s$. This shows a figure consisting of different types of
% lines. Elements of the figure described in the caption should be set in
% italics, in parentheses, as shown in this sample caption.}
% \label{fig:example}
% \end{figure}
%
% This is a table:
% % currsize is not set in the long table environment, so we need to set it before we set it up.
% \makeatletter
% \let\@currsize\normalsize
% \makeatother
%
% % tabular environments are set to be single-spaced in the  thesis class,  but long tables do not use tabular
% % to get around this, set the spacing to single spacing at the start of the long table environment, and set it back to double-spacing at the end of it
%
% \begin{longtable}{c|c|c}
% \caption[This is the title I want to appear in the List of Tables]{This Is a Table Example} \label{tab:pfams} \\
% \hline
% A & B & C \\
% \hline
% \endfirsthead
% \multicolumn{3}{@{}l}{} \\
% \hline
% A & B & C\\
% \hline
% \endhead
% a1 & b1 & c1 \\
% a2 & b2 & c2\\
% a3 & b3 & c3\\
% a4 & b4 & c4\\
% \hline
% \end{longtable}
%
% The package ``upgreek'' allows us to use non-italicized lower-case greek letters. See for yourself: $\upbeta$, $\bm\upbeta$, $\beta$, $\bm\beta$. Next is a numbered equation:
% \begin{align}
% \label{eq:name}
% \|\bm{X}\|_{2,1}={\underbrace{\sum_{j=1}^nf_j(\bm{X})}_{\text{convex}}}=\sum_{j=1}^n\|\bm{X}_{.,j}\|_2
% \end{align}
% The reference to equation (\ref{eq:name}) is clickable.
% \section[Theorems, Corollaries, Lemmas, Proofs, Remarks, Definitions and Examples]{Theorems, Corollaries, Lemmas, Proofs, Remarks, Definitions,and Examples}
%
% \begin{theorem}
% \label{thm:onlytheorem}
% \blindtext
% \end{theorem}
%
% \begin{proof}
% I'm a (very short) proof.
% \end{proof}
%
% \begin{lemma}
% I'm a lemma.
% \end{lemma}
%
% \begin{corollary}
% I include a reference to Thm. \ref{thm:onlytheorem}.
% \end{corollary}
%
% \begin{proposition}
% I'm a proposition.
% \end{proposition}
%
% \begin{remark}
% I'm a remark.
% \end{remark}
%
% \begin{definition}
% I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition. I'm a definition.
% \end{definition}
%
% \begin{example}
% I'm an example.
% \end{example}
%
%
% \section[Optional table of contents heading]{Section with\\ linebreaks in\\the
% name}
%
%
% \Blindtext[2]
