\chapter{Methodology}
\label{chap:met}

This chapter describes generic programming methods implemented in some programming languages,
compares them with features of the Rust programming language and justifies its choice for
the implementation of the library.

\section{Generic programming methods}

% TODO: find articles/books to back this up. Citations!

Mainstream general-purpose programming languages provide features for generic programming. It is
usually achieved through polymorphism (namely, bounded polymorphism, ad-hoc polymorphism, etc).
In this section I discuss polymorphism features implemented in C++ and Java, two popular
programming languages with powerful generic programming mechanisms implemented in different ways.

In Java programs, polymorphism is achieved via either inheritance (a derived class instance
can be used in place of a base class instance), or
Java interfaces (a function parameter is explicitly required to satisfy an interface, and an
instance of a class satisfying the interface can be passed as an argument).
Although logically different, the two methods are technically similar: both require that
an interface of a polymorphic parameter is explicitly defined in the code (either as a
Java interface or a base class), type compatibility for calls is ensured at compile time
(where possible), and method calls for polymorphic parameters are resolved at run time.

In C++ programs, polymorphism can be achieved either through inheritance, or with template
programming. Inheritance in C++ is similar to that in Java: instances of derived classes can
be used in place of instances of base classes; interface of a polymorphic parameter is
explicitly defined in code (the base class), type compatibility is checked
at compile time, and method calls are resolved at run time. As for template programming,
no explicit interface definition is needed (when substituting concrete types for polymorphic
types, compiler will check that all operations used in the function body are defined for
the substituted types), and separate object code is generated for every instance of
a template function (i.e., for every set of type parameters that a polymorphic function is
called with), thus, type checks as well as method call resolution are performed at compile time.

\section{Technologies selected for implementation}

For implementation of the library, I selected the Rust programming language. Rust is a modern
(first stable release in 2015 \footnote{\url{https://releases.rs/}})
compiled general-purpose programming language with a focus on performance and memory safety
\cite{klabnik2023rust}.

In Rust, polymorphism is achieved through explicit definition of a
\emph{trait} \cite{klabnik2023rust} (conceptually similar to a Java interface),
which can be used to accept polymorphic arguments in functions.
Types are checked at compile time, and Rust provides mechanisms for method call
resolution both in compile-time (like in C++ templates, optimizing execution performance)
and run-time (like Java interfaces, optimizing the executable file size),
leaving choice to the programmer.

I selected Rust for its memory safety, flexible generic programming mechanisms, and rich
type system that enables programmer to enforce more invariants in compile time (e.g., with
Algebraic Data Types \cite{klabnik2023rust}).

My library is implemented in pure Rust, relying mostly on the standard library, with an
external dependency on the \texttt{binary\_heap\_plus}
\footnote{\url{https://docs.rs/binary-heap-plus/0.5.0/binary_heap_plus/}} library,
which extends the standard-library implementation of binary heap by providing convenience
features and interfaces.

% =========== TEMPLATE STUFF BELOW ===========

% Referencing other chapters \ref{chap:lr}, \ref{chap:met}, \ref{chap:impl}, \ref{chap:eval} and \ref{chap:conclusion}
% \begin{longtable}{c|c}
% \caption[This is the title I want to appear in the List of Tables]{Simulation Parameters} \label{table:thisimulation_params} \\
% \hline
% A & B  \\
% \hline
% \endfirsthead
% \multicolumn{2}{@{}l}{} \\
% \hline
% A & B \\
% \hline
% \endhead
% \hline
%  \textbf{Parameter} & \textbf{Value}\\
%  \hline
%  Number of vehicles & $|\mathcal{V}|$\\
%  \hline
%  Number of RSUs & $|\mathcal{U}|$\\
%  \hline
%  RSU coverage radius & 150 m\\
%  \hline
%  V2V communication radius & 30 m\\
%  \hline
%  Smart vehicle antenna height & 1.5 m\\
%  \hline
%  RSU antenna height & 25 m\\
%  \hline
%  Smart vehicle maximum speed & $v_{max}$ m/s\\
%  \hline
%  Smart vehicle minimum speed & $v_{min}$ m/s\\
%  \hline
%  Common smart vehicle cache capacities & $[50, 100, 150, 200, 250]$ mb\\
%  \hline
%  Common RSU cache capacities & $[5000,1000,1500,2000,2500]$ mb\\
%  \hline
%  Common backhaul rates & $[75, 100, 150]$ mb/s\\
%  \hline
% \end{longtable}
%
%
% \ldots
