\chapter{Methodology}
\label{chap:met}

This chapter describes generic programming methods implemented in some programming languages,
compares them with features of the Rust programming language and justifies its choice for
the implementation of the library.

\section{Generic programming methods}

% TODO: find articles/books to back this up. Citations!

Mainstream general-purpose programming languages provide features for generic programming. It is
usually achieved through polymorphism (namely, bounded polymorphism, ad-hoc polymorphism, etc).
In this section I discuss polymorphism features implemented in C++ and Java, two popular
programming languages with powerful generic programming mechanisms implemented in different ways.

In Java programs, polymorphism is achieved via either inheritance (a derived class instance
can be used in place of a base class instance), or
Java interfaces (a function parameter is explicitly required to satisfy an interface, and an
instance of a class satisfying the interface can be passed as an argument).
Although logically different, the two methods are technically similar: both require that
an interface of a polymorphic parameter is explicitly defined in the code (either as a
Java interface or a base class), type compatibility for calls is ensured at compile time,
and method calls for polymorphic parameters are resolved at run time.

In C++ programs, polymorphism can be achieved either through inheritance, or with template
programming. Inheritance in C++ is similar to that in Java: instances of derived classes can
be used in place of instances of base classes; interface of a polymorphic parameter is
explicitly defined in code (the base class), type compatibility is checked
at compile time, and method calls are resolved at run time. As for template programming,
no explicit interface definition is required (although may be specified through the
\emph{Constraints and Concepts} feature, starting with C++20
\footnote{\url{https://en.cppreference.com/w/cpp/language/constraints}}):
when substituting concrete types for polymorphic types, the compiler will check that all
operations performed in the function body are valid for the substituted types. For every
instance of a template function (i.e., for every set of type parameters that a polymorphic
function is called with), separate object code is generated. Thus, type checks as well as
method call resolution are performed at compile time.

\section{Technologies selected for implementation}

For implementation of the library, I selected the Rust programming language. Rust is a modern
\footnote{The first stable release of Rust was in 2015: \url{https://releases.rs/}}
compiled general-purpose programming language with a focus on performance and memory safety
\cite{klabnik2023rust}.

I selected Rust for its rich type system, which enables programmer to enforce more invariants
at compile time (e.g., with Algebraic Data Types \cite{klabnik2023rust}).
With this work, I would also like to demonstrate that Rust is a suitable language
for implementations that are heavily based on generic programming.

In Rust, polymorphism is achieved through explicit definition of a
\emph{trait} \cite{klabnik2023rust} (which is conceptually similar to a Java interface or a
C++ concept),
which can be used to accept polymorphic arguments in functions.
Types are checked at compile time, and Rust provides mechanisms for method call
resolution both in compile-time (like with C++ templates, optimizing execution performance)
and run-time (like with Java interfaces or C++ inheritance, optimizing the executable file
size). The programmer may decide which method resolution mechanism to use for each generic
function parameter.

My library is implemented in pure Rust, relying mostly on the standard library, with an
external dependency on the \texttt{binary\_heap\_plus}
\footnote{\url{https://docs.rs/binary-heap-plus/0.5.0/binary_heap_plus/}} library,
which extends the standard-library implementation of binary heap by providing convenience
features and interfaces.

% =========== TEMPLATE STUFF BELOW ===========

% Referencing other chapters \ref{chap:lr}, \ref{chap:met}, \ref{chap:impl}, \ref{chap:eval} and \ref{chap:conclusion}
% \begin{longtable}{c|c}
% \caption[This is the title I want to appear in the List of Tables]{Simulation Parameters} \label{table:thisimulation_params} \\
% \hline
% A & B  \\
% \hline
% \endfirsthead
% \multicolumn{2}{@{}l}{} \\
% \hline
% A & B \\
% \hline
% \endhead
% \hline
%  \textbf{Parameter} & \textbf{Value}\\
%  \hline
%  Number of vehicles & $|\mathcal{V}|$\\
%  \hline
%  Number of RSUs & $|\mathcal{U}|$\\
%  \hline
%  RSU coverage radius & 150 m\\
%  \hline
%  V2V communication radius & 30 m\\
%  \hline
%  Smart vehicle antenna height & 1.5 m\\
%  \hline
%  RSU antenna height & 25 m\\
%  \hline
%  Smart vehicle maximum speed & $v_{max}$ m/s\\
%  \hline
%  Smart vehicle minimum speed & $v_{min}$ m/s\\
%  \hline
%  Common smart vehicle cache capacities & $[50, 100, 150, 200, 250]$ mb\\
%  \hline
%  Common RSU cache capacities & $[5000,1000,1500,2000,2500]$ mb\\
%  \hline
%  Common backhaul rates & $[75, 100, 150]$ mb/s\\
%  \hline
% \end{longtable}
%
%
% \ldots
